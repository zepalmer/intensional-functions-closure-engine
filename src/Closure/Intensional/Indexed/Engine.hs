{-# LANGUAGE IntensionalFunctions #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

module Closure.Intensional.Indexed.Engine
( Computation
, ComputationT
, Engine(..)
, emptyEngine
, addIndex
, addComputation
, addFact
, addFacts
, isClosed
, step
, stepWithFacts
, close
, getIndexedFact
, getAllIndexedFacts
, addIntermediateComputation
, addIntermediateFact
, addIntermediateFacts
, IndexingFunction
) where

import Control.Intensional.Applicative
import Control.Intensional.Functor
import Control.Intensional.Monad
import Control.Intensional.Monad.Trans.Coroutine
import Control.Intensional.Runtime
import Control.Intensional.UtilityFunctions
import Data.Function ((&))
import qualified Data.Set as Set
import Data.Set (Set)
import Data.Typeable (eqT, typeOf, (:~:)(..))

import qualified Closure.Intensional.Indexed.IndexMultiMap as IndexMultiMap
import Closure.Intensional.Indexed.IndexMultiMap (IndexMultiMap)
import Closure.Intensional.Indexed.Types

{-
This module defines an *indexed* coroutine computation engine.  Similar to the
engine provided in the Naive module, this engine contains a set of facts and a
set of computations.  Additionally, the engine contains a series of indexing
functions (in the form of intensional functions) which, given a fact, determine
how (and whether) it should be stored in a given index.  For each fact, one
indexing function may generate a key and a derivative value to be mapped from
that key.

Computations in this indexed engine may access the derivatives for facts by
indexing function and its corresponding key by binding the getIndexedFact
expression provided by this module.  This expression operates much like getFact
from the Naive module in that this bind operation will be executed for each
fact derivative (past and future) which is generated by the corresponding
indexing function.
-}

data ComputationAwaitingIndex fact result where
    ComputationAwaitingIndex :: forall fact key input result.
                                ( Typeable fact
                                , Typeable key
                                , Typeable input
                                , Typeable result
                                , Eq key, Ord key
                                , Ord input
                                )
                             => (IndexingFunction fact key input)
                             -> key
                             -> (input ->%Ord result)
                             -> ComputationAwaitingIndex fact result

instance Eq (ComputationAwaitingIndex fact result) where
    (==)
        (ComputationAwaitingIndex (if1 :: if1) (key1 :: key1) (cont1 :: cont1))
        (ComputationAwaitingIndex (if2 :: if2) (key2 :: key2) (cont2 :: cont2))
        = case eqT of
            Just (Refl :: (if1,key1,cont1) :~: (if2,key2,cont2)) ->
                if1 == if2 && key1 == key2 && cont1 == cont2
            Nothing -> False

instance Ord (ComputationAwaitingIndex fact result) where
    compare
        (ComputationAwaitingIndex (if1 :: if1) (key1 :: key1) (cont1 :: cont1))
        (ComputationAwaitingIndex (if2 :: if2) (key2 :: key2) (cont2 :: cont2))
        = case eqT of
            Just (Refl :: (if1,key1,cont1) :~: (if2,key2,cont2)) ->
                (if1,key1,cont1) `compare` (if2,key2,cont2)
            Nothing ->
                typeOf (if1,key1,cont1) `compare` typeOf (if2,key2,cont2)

data EngineSuspensionFunctor (m :: Type -> Type) fact result
  = ESFAddComputation (() ->%Ord Computation m fact) (() ->%Ord result)
  | ESFAddFacts (Set fact) (() ->%Ord result)
  | ESFAwaitIndex (ComputationAwaitingIndex fact result)

deriving instance (Eq fact) => Eq (EngineSuspensionFunctor m fact result)
deriving instance (Ord fact) => Ord (EngineSuspensionFunctor m fact result)

instance IntensionalFunctor (EngineSuspensionFunctor m fact) where
    type IntensionalFunctorCF (EngineSuspensionFunctor m fact) = Ord
    type IntensionalFunctorMapC (EngineSuspensionFunctor m fact) a b =
        ( Typeable a, Typeable b )
    itsFmap = \%%Ord fn functor ->
      case functor of
        ESFAddComputation computationThunk contfn ->
          ESFAddComputation computationThunk (itsCompose %@% (fn, contfn))
        ESFAddFacts newFacts contfn ->
          ESFAddFacts newFacts (itsCompose %@% (fn, contfn))
        ESFAwaitIndex (ComputationAwaitingIndex idxfn key cont) ->
          ESFAwaitIndex
            (ComputationAwaitingIndex idxfn key (itsCompose %@% (fn, cont)))

type ComputationT m fact =
    CoroutineT Ord (EngineSuspensionFunctor m fact) m

type ComputationStepResult m fact a =
    CoroutineStepResult Ord (EngineSuspensionFunctor m fact) m a

type Computation m fact = ComputationT m fact (Set fact)

-- |These are the constraints that an index-answering workset item must carry.
--  Because input is existential, they cannot be satisfied in the place that the
--  WorksetItem is used.
type WorksetItemConstraints m fact input = -- FIXME: pick a better name
    ( Typeable input -- TODO: are these two constraints necessary?
    , Ord input
    , IntensionalMonadBindC
        m
        (Either
            (EngineSuspensionFunctor m fact (Computation m fact))
            (Set fact))
        (Engine m fact)
    )

data WorksetItem m fact where
    WorksetItem :: forall m fact input.
                              ( WorksetItemConstraints m fact input )
                           => input
                           -> (input ->%Ord (Computation m fact))
                           -> WorksetItem m fact

instance (Typeable m, Typeable fact) => Ord (WorksetItem m fact) where
    compare
        (WorksetItem (input1 :: input1) (cont1 :: cont1))
        (WorksetItem (input2 :: input2) (cont2 :: cont2))
        = case eqT of
            Just (Refl :: (input1, cont1) :~: (input2, cont2)) ->
                (input1, cont1) `compare` (input2, cont2)
            Nothing ->
                typeOf (input1, cont1) `compare` typeOf (input2, cont2)

instance (Ord (WorksetItem m fact)) => Eq (WorksetItem m fact) where
    (==) w1 w2 = w1 `compare` w2 == EQ

newtype FactIndexValue v
    = FactIndexValue v
deriving instance (Eq v) => Eq (FactIndexValue v)
deriving instance (Ord v) => Ord (FactIndexValue v)

data ComputationIndexValue m fact v where
    ComputationIndexValue :: (WorksetItemConstraints m fact v)
                          => (v ->%Ord Computation m fact)
                          -> ComputationIndexValue m fact v
deriving instance Eq (ComputationIndexValue m fact v)
deriving instance Ord (ComputationIndexValue m fact v)

data Engine m fact = Engine
    { facts :: Set fact
    , indexedFacts :: IndexMultiMap fact FactIndexValue
    , indexedComputations :: IndexMultiMap fact (ComputationIndexValue m fact)
    , workset :: Set (WorksetItem m fact)
    }

deriving instance (Typeable m, Typeable fact, Eq fact) => Eq (Engine m fact)
deriving instance (Typeable m, Typeable fact, Ord fact) => Ord (Engine m fact)

emptyEngine :: Engine m fact
emptyEngine = Engine { facts = Set.empty
                     , indexedFacts = IndexMultiMap.empty
                     , indexedComputations = IndexMultiMap.empty
                     , workset = Set.empty
                     }

combineFactWithIndex :: forall fact key derivative m.
                        ( Typeable fact
                        , Typeable (key, derivative)
                        , Typeable m
                        , Ord key
                        , Ord derivative
                        )
                     => fact
                     -> IndexingFunction fact key derivative
                     -> Engine m fact
                     -> Maybe (key, derivative, Set (WorksetItem m fact))
combineFactWithIndex fact idxfn engine =
    case idxfn %@ fact of
        Nothing -> Nothing
        Just (key, derivative) ->
            if IndexMultiMap.contains
                    idxfn key (FactIndexValue derivative) (indexedFacts engine)
            then
                Nothing
            else
                let matchingComputations =
                        IndexMultiMap.find idxfn key
                            (indexedComputations engine)
                in
                let newWorksetItems =
                        matchingComputations
                        & Set.map
                            (\(ComputationIndexValue computation) ->
                                WorksetItem derivative computation)
                in
                Just (key, derivative, newWorksetItems)

addIndex :: forall fact key derivative m.
            ( Typeable fact
            , Typeable key
            , Typeable m
            , Ord key
            , WorksetItemConstraints m fact derivative
            )
         => IndexingFunction fact key derivative
         -> Engine m fact
         -> Engine m fact
addIndex idxfn engine =
    -- Start by adding the index function to the engine's maps.  This is
    -- necessary because we fold over those maps to find indexing functions in
    -- other routines and this routine may not otherwise add the indexing
    -- function here.
    let engine' =
          Engine { facts = facts engine
                 , indexedFacts =
                     IndexMultiMap.addIndex idxfn $ indexedFacts engine
                 , indexedComputations =
                     IndexMultiMap.addIndex idxfn $ indexedComputations engine
                 , workset = workset engine
                 }
    in
    -- Now that we've added the new index, let's compute all of the derivatives
    -- that should exist for it from the set of facts we already have.  Add them
    -- to the indexed fact dictionary.
    let (newFactIndexMap, newWorksetItems) =
          Set.fold
            (\fact (m, s) ->
                case combineFactWithIndex fact idxfn engine' of
                    Nothing -> (m, s)
                    Just (key, derivative, items) ->
                        let m' = IndexMultiMap.add
                                    idxfn key (FactIndexValue derivative) m
                        in
                        (m', Set.union s items)
            )
            (indexedFacts engine', Set.empty)
            (facts engine')
    in
    -- That should do it: the engine is now prepared to act on requests for
    -- facts at that index.
    Engine { facts = facts engine'
           , indexedFacts = newFactIndexMap
           , indexedComputations = indexedComputations engine'
           , workset = Set.union newWorksetItems $ workset engine'
           }

pullOnComputation :: forall m fact.
                     ( IntensionalFunctorCF m ~ Ord
                     , Typeable fact
                     , Ord fact
                     , IntensionalMonad m
                     , IntensionalApplicativePureC m (Engine m fact)
                     , IntensionalApplicativePureC m
                              (Engine m fact, Set fact)
                     , IntensionalApplicativePureC m
                        ( Maybe (ComputationAwaitingIndex
                                    fact (Computation m fact))
                        , Engine m fact
                        , Set fact
                        )
                     , IntensionalMonadBindC m
                        (Either
                          (EngineSuspensionFunctor m fact (Computation m fact))
                          (Set fact))
                        (Engine m fact)
                     , IntensionalMonadBindC m
                        (Either
                          (EngineSuspensionFunctor m fact (Computation m fact))
                          (Set fact))
                        ( Maybe (ComputationAwaitingIndex
                                    fact (Computation m fact))
                        , Engine m fact
                        , Set fact
                        )
                     , IntensionalMonadBindC m
                        (Engine m fact, Set fact)
                        ( Maybe (ComputationAwaitingIndex
                                    fact (Computation m fact))
                        , Engine m fact, Set fact
                        )
                     , IntensionalMonadBindC m
                               (Maybe
                                  (ComputationAwaitingIndex
                                    fact (Computation m fact)),
                                Engine m fact, Set fact)
                               (Engine m fact, Set fact)
                     , IntensionalMonadBindC m
                        ( Maybe (ComputationAwaitingIndex
                                    fact (Computation m fact))
                        , Engine m fact, Set fact )
                        ( Maybe (ComputationAwaitingIndex
                                    fact (Computation m fact))
                        , Engine m fact, Set fact )
                     )
                  => Computation m fact
                  -> Engine m fact
                  -> m ( Maybe
                            (ComputationAwaitingIndex fact (Computation m fact))
                       , Engine m fact
                       , Set fact
                       )
pullOnComputation computation engine =
  intensional Ord do
    result <- resume computation
    case result of
      Left (ESFAddComputation computationThunk contfn) ->
        intensional Ord do
          (engine', newFacts) <-
            addComputationWithFacts (computationThunk %@ ()) engine
          let computation' = contfn %@ ()
          (maybeCAI, engine'', newFacts') <-
            pullOnComputation computation' engine'
          itsPure %@ (maybeCAI, engine'', newFacts `Set.union` newFacts')
      Left (ESFAddFacts newFacts contfn) ->
        let engine' = addFacts (Set.toList newFacts) engine in
        let computation' = contfn %@ () in
        intensional Ord do
          (maybeCAI, engine'', newFacts') <-
            pullOnComputation computation' engine'
          itsPure %@ (maybeCAI, engine'', newFacts `Set.union` newFacts')
      Left (ESFAwaitIndex computationAwaitingIndex) ->
        itsPure %@ (Just computationAwaitingIndex, engine, Set.empty)
      Right factSet ->
        itsPure %@ (Nothing, engine, factSet `Set.difference` facts engine)

addComputationWithFacts :: forall m fact.
                           ( Typeable fact
                           , Ord fact
                           , IntensionalFunctorCF m ~ Ord
                           , IntensionalMonad m
                           , IntensionalApplicativePureC m (Engine m fact)
                           , IntensionalApplicativePureC m
                              (Engine m fact, Set fact)
                           , IntensionalApplicativePureC m
                              ( Maybe (ComputationAwaitingIndex
                                          fact (Computation m fact))
                              , Engine m fact
                              , Set fact
                              )
                           , IntensionalMonadBindC m
                               (Either (EngineSuspensionFunctor m fact
                                             (Computation m fact))
                                       (Set fact))
                               (Engine m fact)
                           , IntensionalMonadBindC m
                               (Maybe
                                  (ComputationAwaitingIndex
                                    fact (Computation m fact)),
                                Engine m fact, Set fact)
                               (Engine m fact, Set fact)
                           , IntensionalMonadBindC m
                               (Either
                                (EngineSuspensionFunctor m
                                  fact (Computation m fact)) (Set fact))
                                ( Maybe
                                  (ComputationAwaitingIndex
                                    fact (Computation m fact))
                                , Engine m fact
                                , Set fact
                                )
                           , IntensionalMonadBindC m
                                (Engine m fact, Set fact)
                                ( Maybe
                                  (ComputationAwaitingIndex
                                    fact (Computation m fact))
                                , Engine m fact
                                , Set fact
                                )
                           , IntensionalMonadBindC m
                              ( Maybe (ComputationAwaitingIndex
                                          fact (Computation m fact))
                              , Engine m fact, Set fact )
                              ( Maybe (ComputationAwaitingIndex
                                          fact (Computation m fact))
                              , Engine m fact, Set fact )
                           )
                        => Computation m fact
                        -> Engine m fact
                        -> m (Engine m fact, Set fact)
addComputationWithFacts computation engine =
  intensional Ord do
    (maybeCAI, engine', newFacts) <- pullOnComputation computation engine
    itsPure %$
      -- "engine" below is intentionally the *original* engine
      let learnedFacts = newFacts `Set.difference` facts engine in
      ( case maybeCAI of
          Just computationAwaitingIndex ->
            handleComputationAwaitingIndex computationAwaitingIndex engine'
          Nothing ->
            engine'
      , learnedFacts
      )

addComputation :: forall m fact.
                  ( Typeable fact
                  , Ord fact
                  , IntensionalFunctorCF m ~ Ord
                  , IntensionalMonad m
                  , IntensionalApplicativePureC m (Engine m fact)
                  , IntensionalApplicativePureC m
                     (Engine m fact, Set fact)
                  , IntensionalApplicativePureC m
                     ( Maybe (ComputationAwaitingIndex
                                 fact (Computation m fact))
                     , Engine m fact
                     , Set fact
                     )
                  , IntensionalMonadBindC m
                      (Engine m fact, Set fact) (Engine m fact)
                  , IntensionalMonadBindC m
                      (Either (EngineSuspensionFunctor m fact
                                    (Computation m fact))
                              (Set fact))
                      (Engine m fact)
                  , IntensionalMonadBindC m
                      (Maybe
                         (ComputationAwaitingIndex
                           fact (Computation m fact)),
                       Engine m fact, Set fact)
                      (Engine m fact, Set fact)
                  , IntensionalMonadBindC m
                      (Either
                       (EngineSuspensionFunctor m
                         fact (Computation m fact)) (Set fact))
                       ( Maybe
                         (ComputationAwaitingIndex
                           fact (Computation m fact))
                       , Engine m fact
                       , Set fact
                       )
                  , IntensionalMonadBindC m
                       (Engine m fact, Set fact)
                       ( Maybe
                         (ComputationAwaitingIndex
                           fact (Computation m fact))
                       , Engine m fact
                       , Set fact
                       )
                  , IntensionalMonadBindC m
                     ( Maybe (ComputationAwaitingIndex
                                 fact (Computation m fact))
                     , Engine m fact, Set fact )
                     ( Maybe (ComputationAwaitingIndex
                                 fact (Computation m fact))
                     , Engine m fact, Set fact )
                 )
               => Computation m fact
               -> Engine m fact
               -> m (Engine m fact)
addComputation computation engine =
  intensional Ord do
    (engine', _) <- addComputationWithFacts computation engine
    itsPure %@ engine'

addFact :: forall m fact.
           (Typeable fact, Typeable m, Ord fact)
        => fact
        -> Engine m fact
        -> Engine m fact
addFact fact engine =
    -- For each index, produce derivatives.  Then introduce a new workset item
    -- for each new pairing between the derivatives and the indexed computations
    -- corresponding to them.
    let folder :: forall key derivative.
                  ( Typeable (key, derivative)
                  , Ord key
                  , Ord derivative
                  )
               => (IndexMultiMap fact FactIndexValue, Set (WorksetItem m fact))
               -> IndexingFunction fact key derivative
               -> IndexMultiMap.FMultiMap FactIndexValue (key, derivative)
               -> (IndexMultiMap fact FactIndexValue, Set (WorksetItem m fact))
        folder (newFactIndexMap, newWorksetItems) idxfn _ =
            case combineFactWithIndex fact idxfn engine of
                Nothing -> (newFactIndexMap, newWorksetItems)
                Just (key, derivative, newWorksetItems') ->
                    let newFactIndexMap' =
                          IndexMultiMap.add
                            idxfn key (FactIndexValue derivative)
                            newFactIndexMap
                    in
                    ( newFactIndexMap'
                    , Set.union newWorksetItems newWorksetItems'
                    )
    in
    let (updatedFactIndexMap, newWorksetItems) =
          IndexMultiMap.fold
            folder
            (indexedFacts engine, Set.empty)
            (indexedFacts engine)
    in
    Engine { facts = Set.insert fact $ facts engine
           , indexedFacts = updatedFactIndexMap
           , indexedComputations = indexedComputations engine
           , workset = Set.union newWorksetItems $ workset engine
           }

addFacts :: forall m fact.
            (Typeable fact, Typeable m, Ord fact)
         => [fact]
         -> Engine m fact
         -> Engine m fact
addFacts newFacts engine = foldr addFact engine newFacts

handleComputationAwaitingIndex ::
       forall m fact.
       ( Typeable m
       , IntensionalMonadBindC
           m
           (Either (EngineSuspensionFunctor m fact (Computation m fact))
                   (Set fact))
           (Engine m fact)
       )
    => ComputationAwaitingIndex fact (Computation m fact)
    -> Engine m fact
    -> Engine m fact
handleComputationAwaitingIndex computationAwaitingIndex engine =
    -- The computationAwaitingIndex argument is waiting for results from a
    -- specific index and key.  For each derivative of that index and key,
    -- produce a workset item pairing the derivative with this new computation.
    case computationAwaitingIndex of
      ComputationAwaitingIndex idxfn key action ->
        if IndexMultiMap.contains
                idxfn key (ComputationIndexValue action)
                (indexedComputations engine)
        then
            engine
        else
            let derivatives =
                  engine
                  & indexedFacts
                  & IndexMultiMap.find idxfn key
            in
            let newWorksetItems =
                  Set.map
                    (\(FactIndexValue derivative) ->
                        WorksetItem derivative action)
                    derivatives
            in
            Engine { facts = facts engine
                   , indexedFacts = indexedFacts engine
                   , indexedComputations =
                       indexedComputations engine
                       & IndexMultiMap.add
                            idxfn key (ComputationIndexValue action)
                   , workset = Set.union newWorksetItems $ workset engine
                   }

isClosed :: Engine m fact -> Bool
isClosed engine = Set.null $ workset engine

step :: forall m fact.
        ( Typeable fact
        , Ord fact
        , IntensionalFunctorCF m ~ Ord
        , IntensionalMonad m
        , IntensionalFunctorMapC m (Engine m fact, Set fact) (Engine m fact)
        , IntensionalApplicativePureC m (Engine m fact)
        , IntensionalApplicativePureC m
           (Engine m fact, Set fact)
        , IntensionalApplicativePureC m
           ( Maybe (ComputationAwaitingIndex
                       fact (Computation m fact))
           , Engine m fact
           , Set fact
           )
        , IntensionalMonadBindC m
            (Either (EngineSuspensionFunctor m fact
                          (Computation m fact))
                    (Set fact))
            (Engine m fact)
        , IntensionalMonadBindC m
            (Maybe
               (ComputationAwaitingIndex
                 fact (Computation m fact)),
             Engine m fact, Set fact)
            (Engine m fact, Set fact)
        , IntensionalMonadBindC m
            (Either
             (EngineSuspensionFunctor m
               fact (Computation m fact)) (Set fact))
             ( Maybe
               (ComputationAwaitingIndex
                 fact (Computation m fact))
             , Engine m fact
             , Set fact
             )
        , IntensionalMonadBindC m
             (Engine m fact, Set fact)
             ( Maybe
               (ComputationAwaitingIndex
                 fact (Computation m fact))
             , Engine m fact
             , Set fact
             )
        , IntensionalMonadBindC m
           ( Maybe (ComputationAwaitingIndex
                       fact (Computation m fact))
           , Engine m fact, Set fact )
           ( Maybe (ComputationAwaitingIndex
                       fact (Computation m fact))
           , Engine m fact, Set fact )
        )
     => Engine m fact
     -> m (Engine m fact)
step engine = itsFmap %@% ((\%Ord (x,_) -> x), stepWithFacts engine)

stepWithFacts :: forall m fact.
                 ( Typeable fact
                 , Ord fact
                 , IntensionalFunctorCF m ~ Ord
                 , IntensionalMonad m
                 , IntensionalApplicativePureC m (Engine m fact)
                 , IntensionalApplicativePureC m
                    (Engine m fact, Set fact)
                 , IntensionalApplicativePureC m
                    ( Maybe (ComputationAwaitingIndex
                                fact (Computation m fact))
                    , Engine m fact
                    , Set fact
                    )
                 , IntensionalMonadBindC m
                     (Either (EngineSuspensionFunctor m fact
                                   (Computation m fact))
                             (Set fact))
                     (Engine m fact)
                 , IntensionalMonadBindC m
                     (Maybe
                        (ComputationAwaitingIndex
                          fact (Computation m fact)),
                      Engine m fact, Set fact)
                     (Engine m fact, Set fact)
                 , IntensionalMonadBindC m
                     (Either
                      (EngineSuspensionFunctor m
                        fact (Computation m fact)) (Set fact))
                      ( Maybe
                        (ComputationAwaitingIndex
                          fact (Computation m fact))
                      , Engine m fact
                      , Set fact
                      )
                 , IntensionalMonadBindC m
                      (Engine m fact, Set fact)
                      ( Maybe
                        (ComputationAwaitingIndex
                          fact (Computation m fact))
                      , Engine m fact
                      , Set fact
                      )
                 , IntensionalMonadBindC m
                    ( Maybe (ComputationAwaitingIndex
                                fact (Computation m fact))
                    , Engine m fact, Set fact )
                    ( Maybe (ComputationAwaitingIndex
                                fact (Computation m fact))
                    , Engine m fact, Set fact )
                 )
              => Engine m fact
              -> m (Engine m fact, Set fact)
stepWithFacts engine =
  case Set.minView $ workset engine of
    Nothing -> itsPure %@ (engine, Set.empty)
    Just ( WorksetItem
              (arg :: arg)
              (action :: arg ->%Ord (Computation m fact))
         , workset'
         ) ->
      let engine' = engine { workset = workset' } in
      let computation = action %@ arg in
      addComputationWithFacts computation engine'

close :: ( Typeable fact
         , Ord fact
         , Ord (Engine m fact)
         , IntensionalMonad m
         , IntensionalFunctorCF m ~ Ord
         , IntensionalFunctorMapC m (Engine m fact, Set fact) (Engine m fact)
         , IntensionalApplicativePureC m (Engine m fact)
         , IntensionalApplicativePureC m (Engine m fact, Set fact)
         , IntensionalApplicativePureC m
            ( Maybe (ComputationAwaitingIndex
                        fact (Computation m fact))
            , Engine m fact
            , Set fact
            )
         , IntensionalMonadBindC m (Engine m fact) (Engine m fact)
         , IntensionalMonadBindC m
             (Either
               (EngineSuspensionFunctor m fact (Computation m fact))
               (Set fact))
             (Engine m fact, Set fact)
         , IntensionalMonadBindC m
             (Either (EngineSuspensionFunctor m fact
                           (Computation m fact))
                     (Set fact))
             (Engine m fact)
         , IntensionalMonadBindC m
             (Maybe
                (ComputationAwaitingIndex
                  fact (Computation m fact)),
              Engine m fact, Set fact)
             (Engine m fact, Set fact)
         , IntensionalMonadBindC m
             (Either
              (EngineSuspensionFunctor m
                fact (Computation m fact)) (Set fact))
              ( Maybe
                (ComputationAwaitingIndex
                  fact (Computation m fact))
              , Engine m fact
              , Set fact
              )
         , IntensionalMonadBindC m
              (Engine m fact, Set fact)
              ( Maybe
                (ComputationAwaitingIndex
                  fact (Computation m fact))
              , Engine m fact
              , Set fact
              )
         , IntensionalMonadBindC m
            ( Maybe (ComputationAwaitingIndex
                        fact (Computation m fact))
            , Engine m fact, Set fact )
            ( Maybe (ComputationAwaitingIndex
                        fact (Computation m fact))
            , Engine m fact, Set fact )
         )
      => Engine m fact -> m (Engine m fact)
close engine =
  if isClosed engine then itsPure %@ engine else intensional Ord do
    engine' <- step engine
    close engine'

{- TODO: revisit names of public functions.  The name should indicate somehow
   whether or not it should be used within a monadic computation or on an
   engine. -}

getIndexedFact :: forall m fact key derivative.
                  ( Typeable fact
                  , Typeable key
                  , Typeable derivative
                  , Ord key
                  , Ord derivative
                  , IntensionalMonad m
                  , IntensionalFunctorCF m ~ Ord
                  , IntensionalApplicativePureC m
                      (ComputationStepResult m fact derivative)
                  )
               => IndexingFunction fact key derivative
               -> key
               -> CoroutineT
                    Ord (EngineSuspensionFunctor m fact) m derivative
getIndexedFact idxfn key =
    suspend (ESFAwaitIndex (ComputationAwaitingIndex idxfn key itsPure))

{-
get :: State s s
get = (\s -> (s, s))

set :: s -> State s ()
set x = (\_ -> (x, ()))
-}

getAllIndexedFacts :: forall m fact key derivative.
                      ( Typeable fact
                      , Typeable key
                      , Typeable derivative
                      , Ord key
                      , Ord derivative
                      )
                   => IndexingFunction fact key derivative
                   -> key
                   -> Engine m fact
                   -> Set derivative
getAllIndexedFacts idxfn key engine =
    let wrappedFacts = IndexMultiMap.find idxfn key $ indexedFacts engine in
    Set.map (\(FactIndexValue value) -> value) wrappedFacts

addIntermediateComputation :: forall m fact.
                              ( IntensionalFunctorCF m ~ Ord
                              , Typeable fact
                              , IntensionalMonad m
                              , IntensionalApplicativePureC m
                                    (ComputationStepResult m fact ())
                              )
                           => (() ->%Ord Computation m fact)
                           -> CoroutineT Ord
                                (EngineSuspensionFunctor m fact) m ()
addIntermediateComputation computationThunk =
    suspend (ESFAddComputation computationThunk itsPure)

addIntermediateFact :: forall m fact.
                       ( IntensionalFunctorCF m ~ Ord
                       , Typeable fact
                       , IntensionalMonad m
                       , IntensionalApplicativePureC m
                            (ComputationStepResult m fact ())
                       )
                    => fact
                    -> CoroutineT Ord
                        (EngineSuspensionFunctor m fact) m ()
addIntermediateFact fact =
    suspend (ESFAddFacts (Set.singleton fact) itsPure)

addIntermediateFacts ::
       forall m fact.
       ( Typeable fact
       , Ord fact
       , IntensionalFunctorCF m ~ Ord
       , IntensionalMonad m
       , IntensionalApplicativePureC m (ComputationStepResult m fact ())
       )
    => [fact]
    -> CoroutineT Ord
        (EngineSuspensionFunctor m fact) m ()
addIntermediateFacts newFacts =
    suspend (ESFAddFacts (Set.fromList newFacts) itsPure)
